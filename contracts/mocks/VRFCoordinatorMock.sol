// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

// import "../WorkerBatch.sol";

import "hardhat/console.sol";

contract VRFCoordinatorMock {

    LinkTokenInterface public LINK;
    mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;
    bytes32[] private keyHashes;

    event RandomnessRequest(address indexed sender, bytes32 indexed keyHash, uint256 indexed seed, bytes32 requestId);

    constructor(address linkAddress) {
      LINK = LinkTokenInterface(linkAddress);
    }

    function onTokenTransfer(address sender, uint256 fee, bytes memory _data) public onlyLINK {
      (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));
      uint256 vrfInputSeed = makeVRFInputSeed(keyHash, seed, sender, nonces[keyHash]);
      bytes32 requestId = makeRequestId(keyHash, vrfInputSeed);
      keyHashes.push(keyHash);
      nonces[keyHash] = nonces[keyHash] + 1;
      emit RandomnessRequest(sender, keyHash, seed, requestId);
    }

  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed, address _requester, uint256 _nonce) internal pure returns (uint256) {
    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
  }

  /**
   * @notice Returns the id for this request
   * @param _keyHash The serviceAgreement ID to be used for this request
   * @param _vRFInputSeed The seed to be passed directly to the VRF
   * @return The id for this request
   *
   * @dev Note that _vRFInputSeed is not the seed passed by the consuming
   * @dev contract, but the one generated by makeVRFInputSeed
   */
  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
  }

  function callBackWithRandomness(bytes32 requestId, uint256 randomness, address consumerContract) public {
    VRFConsumerBase v;
    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomness.selector, requestId, randomness);
    uint256 b = 206000;
    require(gasleft() >= b, "not enough gas for consumer");
    (bool success,) = consumerContract.call(resp);
  }

  function reset() public {
    console.log('resetting oracle, deleting %d keys', keyHashes.length);
    for (uint i = 0; i < keyHashes.length; i++) {
      console.log('deleting key');
      console.logBytes32(keyHashes[i]);
      nonces[keyHashes[i]] = 0;
      console.log('new value %d', nonces[keyHashes[i]]);
    }
    delete keyHashes;
  }

  modifier onlyLINK() {
    require(msg.sender == address(LINK), "Must use LINK token");
    _;
  }
}